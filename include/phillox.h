#ifndef PHILLOX_H
#define PHILLOX_H

#include <array>
#include <cstdint>
#include <iostream>
#include <limits>

#include "base_state.hpp"

namespace {

#ifndef PHILOX_M4x32_0
#define PHILOX_M4x32_0 ((uint32_t)0xD2511F53)
#endif
#ifndef PHILOX_M4x32_1
#define PHILOX_M4x32_1 ((uint32_t)0xCD9E8D57)
#endif

#ifndef PHILOX_W32_0
#define PHILOX_W32_0 ((uint32_t)0x9E3779B9)
#endif
#ifndef PHILOX_W32_1
#define PHILOX_W32_1 ((uint32_t)0xBB67AE85)
#endif


inline DEVICE uint32_t mulhilo(uint32_t L, uint32_t R, uint32_t *hip) {
  uint64_t product = static_cast<uint64_t>(L) * static_cast<uint64_t>(R);
  *hip = product >> 32;
  return static_cast<uint32_t>(product);
}


inline DEVICE void round(const uint32_t (&key)[2], uint32_t (&ctr)[4]) {
  uint32_t hi0;
  uint32_t hi1;
  uint32_t lo0 = mulhilo(PHILOX_M4x32_0, ctr[0], &hi0);
  uint32_t lo1 = mulhilo(PHILOX_M4x32_1, ctr[2], &hi1);
  ctr[0] = hi1 ^ ctr[1] ^ key[0];
  ctr[1] = lo1;
  ctr[2] = hi0 ^ ctr[3] ^ key[1];
  ctr[3] = lo0;
}
} // namespace


/**
 * @class Phillox
 * @brief Phillox generator
 * @note This is a modified version of Phillox generator from Random123 library.
 */
class Phillox : public BaseRNG<Phillox> {

public:
  DEVICE Phillox(uint64_t seed_, uint64_t counter_)
      : seed_hi((uint32_t)(seed_ >> 32)), 
        seed_lo((uint32_t)(seed_ & 0xFFFFFFFF)),
        counter(counter_) {}


  template <typename T = uint32_t> DEVICE T draw() {
    generate();

    static_assert(std::is_same_v<T, uint32_t> || std::is_same_v<T, uint64_t>);
    if constexpr (std::is_same_v<T, uint32_t>)
      return _out[0];

    uint64_t res =
        (static_cast<uint64_t>(_out[0]) << 32) | static_cast<uint64_t>(_out[1]);
    return static_cast<uint64_t>(res);
  }

private:
  DEVICE void generate() {
    uint32_t key[2] = {seed_hi, seed_lo};
    // The counter takes first 2 values from internal counter, next 2 from
    // what the user provided during instantiation. The internal counter helps
    // to avoid forcing user to increment counter each time a number is
    // generated.
    _out[0] = (uint32_t)(_ctr >> 32);
    _out[1] = (uint32_t)(_ctr & 0xFFFFFFFF);
    _out[2] = (uint32_t)(counter >> 32);
    _out[3] = (uint32_t)(counter & 0xFFFFFFFF);

    for (int r = 0; r < 10; r++) {
      if (r > 0){
        key[0] += PHILOX_W32_0;
        key[1] += PHILOX_W32_1;
      }
      round(key, _out);
    } 
    _ctr++;
  }

  //TODO: Optimize away the internal counter. Use one counter state. 
  const uint32_t seed_hi, seed_lo;
  const uint64_t counter;
  // private counter to keep track of numbers generated by this instance of rng
  uint64_t _ctr = 0;
  uint32_t _out[4];
  };



#endif // PHILLOX_H